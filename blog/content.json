{"meta":{"title":"Duckywang","subtitle":null,"description":"小学生放暑假打前端工程师","author":"Duckywang","url":"http://duckywang1.github.io/blog"},"pages":[],"posts":[{"title":"JQ的Post封装","slug":"JQ的Post封装","date":"2016-06-30T17:17:04.000Z","updated":"2016-06-30T17:22:22.000Z","comments":true,"path":"2016/07/01/JQ的Post封装/","link":"","permalink":"http://duckywang1.github.io/blog/blog/2016/07/01/JQ的Post封装/","excerpt":"","text":"JQ的优点balabala一大堆，不描述了。这样封装解决的场景是：如果点击提交／注册，没有拦截的话，如果点多几次，就会重复提交，故封装一层。使用方法 $(this).post(); 原生的是 $.post(); 源码 嗯。。结合了layer做了个提示 (function ($) { $.fn.post = function (url, data, successfunc, type, needLoad) { var el = this; if ($(el).hasClass('postDisable')) { return; } var needload = needLoad ? needLoad : 0; if (needload == 0) { var index = layer.load(); } $.ajax({ url: url, type: 'post', cache: false, data: data, dataType: type || \"json\", beforeSend: function () {//触发ajax请求开始时执行 $(el).addClass(\"postDisable\"); }, success: successfunc, error: function () {//ajax发生错误时执行 $(el).removeClass(\"postDisable\"); if (needload == 0) { layer.close(index); } }, complete: function () {//ajax请求完成时执行 $(el).removeClass(\"postDisable\"); if (needload == 0) { layer.close(index); } } }); }; })(jQuery);","categories":[{"name":"前端","slug":"前端","permalink":"http://duckywang1.github.io/blog/categories/前端/"}],"tags":[{"name":"FETeam - idianbang","slug":"FETeam-idianbang","permalink":"http://duckywang1.github.io/blog/tags/FETeam-idianbang/"},{"name":"前端插件使用","slug":"前端插件使用","permalink":"http://duckywang1.github.io/blog/tags/前端插件使用/"},{"name":"Team内部使用","slug":"Team内部使用","permalink":"http://duckywang1.github.io/blog/tags/Team内部使用/"}]},{"title":"layer封装与调用","slug":"layer封装与调用","date":"2016-06-30T17:07:20.000Z","updated":"2016-06-30T17:14:36.000Z","comments":true,"path":"2016/07/01/layer封装与调用/","link":"","permalink":"http://duckywang1.github.io/blog/blog/2016/07/01/layer封装与调用/","excerpt":"","text":"首先感谢贤心的开源弹窗插件layer.js 我们封装的调用是 $.layer({ title: '必填的标题', content: $('必填的dialog') }, '必填600px', '看窗口高度，选auto或90%'); 封装源码 写的还是有点缺点的，后面再改进。864px 太高了。。。 (function ($) { $.extend({ layer: function (options, LWidth, LHeight) { var LWidth = LWidth || \"600px\"; var LHeight = LHeight || '90%'; if ($(window).height() > 864) { if (LHeight) { LHeight = LHeight; } else { LHeight = '864px'; } } var settings = $.extend({ type: 1, shift: 0, skin: 'layui-layer-demo', title: false, closeBtn: 1, shadeClose: true, move: false, area: [LWidth, LHeight] }, options); return index = layer.open(settings); } }) })(jQuery);","categories":[{"name":"前端","slug":"前端","permalink":"http://duckywang1.github.io/blog/categories/前端/"}],"tags":[{"name":"FETeam - idianbang","slug":"FETeam-idianbang","permalink":"http://duckywang1.github.io/blog/tags/FETeam-idianbang/"},{"name":"前端插件使用","slug":"前端插件使用","permalink":"http://duckywang1.github.io/blog/tags/前端插件使用/"},{"name":"Team内部使用","slug":"Team内部使用","permalink":"http://duckywang1.github.io/blog/tags/Team内部使用/"}]},{"title":"插件之Webuploader使用并封装指南","slug":"插件之Webuploader使用并封装指南","date":"2016-06-30T15:05:26.000Z","updated":"2016-06-30T17:16:10.000Z","comments":true,"path":"2016/06/30/插件之Webuploader使用并封装指南/","link":"","permalink":"http://duckywang1.github.io/blog/blog/2016/06/30/插件之Webuploader使用并封装指南/","excerpt":"","text":"首先需求是来源于&lt;input type=&quot;file&quot; /&gt;的样式很丑，一开始学习的美化是这样的(感谢网友提供的源代码展示)。做头像上传用到了jquery.cropbox.js，Base64码很好用不解释（同时也得把服务器的上限给调高）。后来由于业务需要传一个完整的图还有表单信息，于是探寻之下发现了WebUploader，于是就开始学习。 对于该类插件，我的印象是初始化，调用，写回调（上传前后该干嘛）。于是我从Getting-started上手，嗯！知道了要写dom结构，要放css，要放js，要调参数，要初始化，要写回调。 原生的webuploader调用并美化&lt;&lt; 封装版本的在更下面 &gt;&gt; 1.引入CSS／JS。过于简单不介绍了。2.写DOM结构 &lt;!-- 我这里删掉了Button，写自己的Button。其余结构不能删掉。--&gt; &lt;div id=\"uploaderIDIDID\"&gt; &lt;div id=\"thelist\" class=\"uploader-list\"&gt;&lt;/div&gt; &lt;div class=\"btns\"&gt; &lt;div id=\"picker\"&gt;选择文件&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 3.写配置 // js里面 var uploader = WebUploader.create({ // swf文件路径 swf: BASE_URL + '/js/Uploader.swf', // 文件接收服务端。 server: 'x x', // 选择文件的按钮。可选。 // 内部根据当前运行是创建，可能是input元素，也可能是flash. pick: '#filePicker', // 只允许选择图片文件。 accept: { title: 'Images', extensions: 'gif,jpg,jpeg,bmp,png', mimeTypes: 'image/*' } }); 4.写回调 // 写一堆函数说上传开始／进行时／成功要干嘛 uploader.on('uploadProgress', func); uploader.on('uploadSuccess', func); 5.黑科技来啦，出发file表单 // 这里就是点击 自定义的选择框 时候 $('自定义选择框').on('click', function () { // 这时候就选择了文件，触发了自己想要做的事情 $('#' + 'uploaderIDIDID' + ' .webuploader-element-invisible').trigger('click').on('change', function () { var fileInfoArr = uploader.getFiles(); //能拿到信息啦！ }); }); 6.提交信息 // 这里就是点击 自定义的选择框 时候 $('submitBtn').on('click', function () { uploader.upload(); }); 封装的webuploader调用并美化1.引入CSS／JS。过于简单不介绍了。2.写DOM结构（通过JS，在初始化前进行插入dom）3.写配置 例如上传图片 第一层每项几乎必填，createParams不是每个都填 apiAddress API地址 fileSize 单位字节, 1M = 1048576 = 1024 * 1024 prefix 与下面的 createParams.pick 息息相关，定义好名字，不要与HTML中别的ID冲突 createParams.swf 已经配好 createParams.server API地址 createParams.file 看API的file应该叫什么字段 createParams.pick 等于 '#' + prefix + 'picker' createParams.formData API中除了文件别的字段，可以通过 路径到.uploader.options('formData', {xx:xx}); 这个API来填充 createParams.method GET还是POST请求 createParams.extensions/mimeTypes 两者关系一一对应的。网上有表可查。用于限制上传文件的类型 var uploaderParams = { BASE_URL: aUtils.BASE_URL, apiAddress: '/uploadImg', fileSize: 1048576, prefix: 'createLesson', cb_uploadSuccess: 路径到.cbUploader_uploadSuccess, createParams: { swf: aUtils.BASE_URL + '/webUploader/Uploader.swf', server: aUtils.BASE_URL + '/uploadUserImg', fileVal: 'file', pick: '#createLessonpicker', resize: false, formData: {}, method: 'POST', extensions: 'gif,jpg,jpeg,bmp,png', mimeTypes: 'image/*', }, }; 4.写函数 // 函数的路径定好，这里写匿名函数只是为了方便看 1. cbUploader_uploadSuccess: function(file, response) { // 放在 里面 // 上传成功后做的函数 }; 2. $('选择框').on('click', function () { // 先清空上一次选的文件 路径到.uploaderObj.uploader.reset(); // 触发file的change事件，这个匿名函数不用迁移 $('#' + 路径到.uploaderObj.pickerId + ' .webuploader-element-invisible').trigger('click').on('change', function () { var fileInfoArr = uploader.getFiles(); //能拿到信息啦！展现什么的 }); }); 3. $('提交按钮').on('click', function() { // 检查数据 // 假设数据没问题，则调用下面的这个upload方法 路径到.uploaderObj.uploader.upload(); }); 分模块写好～","categories":[{"name":"前端","slug":"前端","permalink":"http://duckywang1.github.io/blog/categories/前端/"}],"tags":[{"name":"FETeam - idianbang","slug":"FETeam-idianbang","permalink":"http://duckywang1.github.io/blog/tags/FETeam-idianbang/"},{"name":"前端插件使用","slug":"前端插件使用","permalink":"http://duckywang1.github.io/blog/tags/前端插件使用/"},{"name":"Team内部使用","slug":"Team内部使用","permalink":"http://duckywang1.github.io/blog/tags/Team内部使用/"}]}]}